#!/usr/bin/env bash
# Clean up Chief Wiggum worktrees and worker directories

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
source "$WIGGUM_HOME/lib/exit-codes.sh"
source "$WIGGUM_HOME/lib/defaults.sh"
source "$WIGGUM_HOME/lib/worker-lifecycle.sh"

SKIP_CONFIRM=false

show_help() {
    cat << EOF
wiggum clean - Clean up worktrees and worker directories

Usage: wiggum clean [options] <target>

Targets:
  <pattern>           Clean workers matching pattern (e.g., TASK-001, 030)
  <p1>,<p2>,...       Clean multiple patterns (comma-separated)
  all                 Clean all worktrees and worker directories

Options:
  -y, --yes           Skip confirmation prompt
  -h, --help          Show this help message

Description:
  Removes git worktrees created by workers and cleans up the
  .ralph/workers/ directory. This does not affect the main repository.

  Pattern matching: searches for worker directories matching the pattern.
  Proceeds only if exactly one match is found per pattern.

Examples:
  wiggum clean TASK-001       # Clean workers matching TASK-001
  wiggum clean 030            # Clean workers matching "030"
  wiggum clean TASK-001,002   # Clean workers for TASK-001 and those matching "002"
  wiggum clean all            # Clean up all worktrees and worker directories
  wiggum clean -y all         # Clean all without confirmation

EOF
}

log() {
    echo "[$(date -Iseconds)] $*"
}

confirm() {
    local prompt="$1"
    if [ "$SKIP_CONFIRM" = true ]; then
        return 0
    fi
    read -r -p "$prompt [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY])
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Check if a worker is running (wrapper around shared library)
# Returns 0 if running, 1 if not
check_worker_running() {
    local worker_name="$1"
    local worker_dir="$RALPH_DIR/workers/$worker_name"
    is_worker_running "$worker_dir"
}

# Find matching worker directories for a pattern
# Returns: matched directory names (one per line)
find_matches() {
    local pattern="$1"

    if [ ! -d "$RALPH_DIR/workers" ]; then
        return
    fi

    # List directories matching the pattern
    for dir in "$RALPH_DIR/workers"/worker-*; do
        if [ -d "$dir" ]; then
            local dirname=$(basename "$dir")
            if [[ "$dirname" =~ $pattern ]]; then
                echo "$dirname"
            fi
        fi
    done
}

# Find all worker directories
find_all_workers() {
    if [ ! -d "$RALPH_DIR/workers" ]; then
        return
    fi

    for dir in "$RALPH_DIR/workers"/worker-*; do
        if [ -d "$dir" ]; then
            basename "$dir"
        fi
    done
}

clean_worker() {
    local worker_dir="$RALPH_DIR/workers/$1"

    # Remove worktree if exists
    if [ -d "$worker_dir/workspace" ]; then
        log "Removing worktree: $worker_dir/workspace"
        git worktree remove "$worker_dir/workspace" --force 2>/dev/null || true
    fi

    # Remove worker directory
    if [ -d "$worker_dir" ]; then
        log "Removing worker directory: $1"
        rm -rf "$worker_dir"
    fi
}

# Resolve patterns to worker directories
# Returns: list of workers to clean (one per line), or error message on stderr
resolve_patterns() {
    local input="$1"
    local resolved=()

    IFS=',' read -ra patterns <<< "$input"
    for pattern in "${patterns[@]}"; do
        # Trim whitespace
        pattern=$(echo "$pattern" | xargs)
        if [ -z "$pattern" ]; then
            continue
        fi

        local matches
        matches=$(find_matches "$pattern")

        if [ -z "$matches" ]; then
            echo "No workers found matching: $pattern" >&2
            return 1
        fi

        local match_count=$(echo "$matches" | wc -l)

        if [ "$match_count" -gt 1 ]; then
            echo "Multiple workers match '$pattern':" >&2
            echo "$matches" | sed 's/^/  /' >&2
            echo "Please be more specific." >&2
            return 1
        fi

        resolved+=("$(echo "$matches" | head -1)")
    done

    printf '%s\n' "${resolved[@]}"
}

do_clean() {
    local workers=("$@")

    for worker in "${workers[@]}"; do
        clean_worker "$worker"
    done

    # Prune stale worktree references
    git worktree prune 2>/dev/null

    log "âœ“ Cleaned ${#workers[@]} worker(s)"

    # Show current status
    echo ""
    log "Current status:"
    git worktree list
}

# Parse options
TARGET=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -y|--yes)
            SKIP_CONFIRM=true
            shift
            ;;
        -h|--help)
            show_help
            exit $EXIT_OK
            ;;
        -*)
            echo "Unknown option: $1"
            echo ""
            show_help
            exit $EXIT_USAGE
            ;;
        *)
            if [ -z "$TARGET" ]; then
                TARGET="$1"
            else
                echo "Unexpected argument: $1"
                exit $EXIT_USAGE
            fi
            shift
            ;;
    esac
done

# Require a target
if [ -z "$TARGET" ]; then
    echo "No target specified. Use 'wiggum clean <pattern>' or 'wiggum clean all'."
    echo ""
    show_help
    exit $EXIT_OK
fi

# Check .ralph directory exists
if [ ! -d "$RALPH_DIR" ]; then
    echo "ERROR: .ralph/ directory not found"
    exit $EXIT_CLEAN_NO_RALPH_DIR
fi

# Determine workers to clean
if [ "$TARGET" = "all" ]; then
    workers_to_clean=$(find_all_workers)
else
    workers_to_clean=$(resolve_patterns "$TARGET") || exit $EXIT_CLEAN_PATTERN_NOT_FOUND
fi

if [ -z "$workers_to_clean" ]; then
    echo "No workers to clean."
    exit $EXIT_OK
fi

# Convert to array
mapfile -t workers_array <<< "$workers_to_clean"

# Check for running workers
running_workers=()
for worker in "${workers_array[@]}"; do
    if check_worker_running "$worker"; then
        running_workers+=("$worker")
    fi
done

if [ ${#running_workers[@]} -gt 0 ]; then
    echo "ERROR: Cannot clean running workers. Stop them first with 'wiggum worker <id> stop'."
    echo ""
    echo "Running workers:"
    for worker in "${running_workers[@]}"; do
        echo "  $worker"
    done
    exit $EXIT_CLEAN_WORKERS_RUNNING
fi

# Show what will be cleaned and ask for confirmation
echo "The following worker directories will be removed:"
for worker in "${workers_array[@]}"; do
    echo "  $worker"
done
echo ""

if ! confirm "Proceed with cleanup?"; then
    echo "Aborted."
    exit $EXIT_OK
fi

# Do the cleanup
do_clean "${workers_array[@]}"
