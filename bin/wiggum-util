#!/usr/bin/env bash
# wiggum util - Utility subcommands
set -euo pipefail

WIGGUM_HOME="${WIGGUM_HOME:-$HOME/.claude/chief-wiggum}"
source "$WIGGUM_HOME/lib/core/exit-codes.sh"
source "$WIGGUM_HOME/lib/core/defaults.sh"
source "$WIGGUM_HOME/lib/core/verbose-flags.sh"

show_help() {
    cat << EOF
wiggum util - Utility subcommands

Usage: wiggum util <subcommand> [options]

Subcommands:
  convert-log         Convert JSONL iteration logs to markdown

Global Options:
  -v, --verbose       Verbose output (same as default)
  -vv                 Debug output (detailed diagnostics)
  -vvv                Trace output (very detailed tracing)
  -q, --quiet         Quiet mode (warnings and errors only)

Run 'wiggum util <subcommand> --help' for details on each subcommand.

EOF
}

# --- convert-log ---

convert_log_help() {
    cat << EOF
wiggum util convert-log - Convert JSONL iteration logs to markdown

Usage: wiggum util convert-log [options] <target>

Targets:
  <file.jsonl>        Convert a specific JSONL log file
  <pattern>           Find and convert logs for workers matching pattern

Options:
  -o, --output FILE   Write output to FILE (default: stdout)
  -a, --all           Convert all iteration logs for matched worker
  -h, --help          Show this help message

Description:
  Converts Claude CLI stream-JSON logs (.jsonl) into readable markdown.
  Useful for reviewing what happened during a worker's iteration.

  When given a pattern instead of a file path, searches .ralph/workers/
  for matching worker directories and converts their iteration logs.

Examples:
  wiggum util convert-log iteration-1.jsonl                  # Convert specific file
  wiggum util convert-log TASK-030                           # Latest log for TASK-030
  wiggum util convert-log TASK-030 -a                        # All logs for TASK-030
  wiggum util convert-log TASK-030 -o review.md              # Output to file

EOF
}

# Find iteration log files for a worker pattern
convert_log_find_logs() {
    local pattern="$1"
    local ralph_dir="${RALPH_DIR:-.ralph}"

    if [ ! -d "$ralph_dir/workers" ]; then
        echo "No workers directory found at $ralph_dir/workers" >&2
        return 1
    fi

    local matches=()
    for dir in "$ralph_dir/workers"/worker-*; do
        [ -d "$dir" ] || continue
        local dirname
        dirname=$(basename "$dir")
        if [[ "$dirname" =~ $pattern ]]; then
            matches+=("$dir")
        fi
    done

    if [ ${#matches[@]} -eq 0 ]; then
        echo "No workers found matching: $pattern" >&2
        return 1
    fi

    if [ ${#matches[@]} -gt 1 ]; then
        echo "Multiple workers match '$pattern':" >&2
        for m in "${matches[@]}"; do
            echo "  $(basename "$m")" >&2
        done
        echo "Please be more specific." >&2
        return 1
    fi

    local worker_dir="${matches[0]}"

    local logs=()
    for log in "$worker_dir"/iteration-*.jsonl; do
        [ -f "$log" ] && logs+=("$log")
    done

    if [ ${#logs[@]} -eq 0 ]; then
        echo "No iteration logs found in $(basename "$worker_dir")" >&2
        return 1
    fi

    printf '%s\n' "${logs[@]}" | sort -t'-' -k2 -n
}

cmd_convert_log() {
    local output="" all=false target=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output)
                output="$2"
                shift 2
                ;;
            -a|--all)
                all=true
                shift
                ;;
            -h|--help)
                convert_log_help
                exit $EXIT_OK
                ;;
            -*)
                echo "Unknown option: $1"
                echo ""
                convert_log_help
                exit $EXIT_USAGE
                ;;
            *)
                if [ -z "$target" ]; then
                    target="$1"
                else
                    echo "Unexpected argument: $1"
                    exit $EXIT_USAGE
                fi
                shift
                ;;
        esac
    done

    if [ -z "$target" ]; then
        echo "No target specified."
        echo ""
        convert_log_help
        exit $EXIT_USAGE
    fi

    local converter="$WIGGUM_HOME/lib/utils/log-converter.sh"

    if [ ! -f "$converter" ]; then
        echo "ERROR: log-converter.sh not found at $converter" >&2
        exit $EXIT_ERROR
    fi

    # Determine input files
    local files
    if [ -f "$target" ]; then
        files=("$target")
    else
        mapfile -t files < <(convert_log_find_logs "$target")
    fi

    # If not --all, only use the latest log
    if [ "$all" = false ] && [ ${#files[@]} -gt 1 ]; then
        files=("${files[-1]}")
    fi

    # Convert
    for file in "${files[@]}"; do
        if [ ${#files[@]} -gt 1 ]; then
            echo "--- Converting: $(basename "$file") ---" >&2
        fi

        if [ -n "$output" ]; then
            if [ ${#files[@]} -gt 1 ]; then
                bash "$converter" "$file" >> "$output"
            else
                bash "$converter" "$file" "$output"
            fi
        else
            bash "$converter" "$file"
        fi
    done
}

# --- dispatch ---

# Parse verbose flags first
parse_verbose_flags "$@"
set -- "${WIGGUM_REMAINING_ARGS[@]}"

if [ $# -eq 0 ]; then
    show_help
    exit $EXIT_USAGE
fi

command="$1"
shift

case "$command" in
    convert-log)
        cmd_convert_log "$@"
        ;;
    -h|--help|help)
        show_help
        exit $EXIT_OK
        ;;
    *)
        echo "Unknown util subcommand: $command"
        echo ""
        show_help
        exit $EXIT_USAGE
        ;;
esac
