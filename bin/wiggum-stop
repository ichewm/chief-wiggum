#!/usr/bin/env bash
# Stop all workers

PROJECT_DIR="$(pwd)"
RALPH_DIR="$PROJECT_DIR/.ralph"

show_help() {
    cat << EOF
wiggum stop - Stop running workers

Usage: wiggum stop [options]

Options:
  --workers PIDS      Comma-separated list of worker PIDs to stop
  --orchestrator      Stop the orchestrator process
  -h, --help          Show this help message

Description:
  Gracefully stops workers by sending TERM signal to worker processes.

  Without options: Stops all workers (orchestrator continues and will exit when done)
  With --workers: Stops only specified workers
  With --orchestrator: Stops the orchestrator process (and all workers)

Examples:
  wiggum stop                        # Stop all workers
  wiggum stop --workers 12345        # Stop only worker PID 12345
  wiggum stop --orchestrator         # Stop orchestrator (and all workers)
  wiggum stop --workers 12345,67890  # Stop workers 12345 and 67890

EOF
}

# Parse options
SPECIFIC_WORKERS=""
STOP_ORCHESTRATOR=false
while [[ $# -gt 0 ]]; do
    case "$1" in
        --workers)
            if [[ -z "$2" ]] || [[ "$2" =~ ^- ]]; then
                echo "Error: --workers requires a comma-separated list of PIDs"
                exit 1
            fi
            SPECIFIC_WORKERS="$2"
            shift 2
            ;;
        --orchestrator)
            STOP_ORCHESTRATOR=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
done

# Handle stopping orchestrator
if [ "$STOP_ORCHESTRATOR" = true ]; then
    orchestrator_lock="$RALPH_DIR/.orchestrator.pid"

    if [ ! -f "$orchestrator_lock" ]; then
        echo "No orchestrator process running"
        exit 0
    fi

    orchestrator_pid=$(cat "$orchestrator_lock" 2>/dev/null)

    # Validate PID is a number
    if ! [[ "$orchestrator_pid" =~ ^[0-9]+$ ]]; then
        echo "Invalid orchestrator PID, cleaning lock file"
        rm -f "$orchestrator_lock"
        exit 0
    fi

    # Check if process is running and is wiggum-run
    if kill -0 "$orchestrator_pid" 2>/dev/null; then
        if ps -p "$orchestrator_pid" -o args= 2>/dev/null | grep -q "wiggum-run"; then
            echo "Stopping orchestrator (PID: $orchestrator_pid)..."
            kill -TERM "$orchestrator_pid"
            echo "Orchestrator stopped (workers will also be terminated by orchestrator cleanup)"
            exit 0
        else
            echo "Process $orchestrator_pid is not wiggum-run (PID reused?)"
            rm -f "$orchestrator_lock"
            exit 0
        fi
    else
        echo "Orchestrator process not running, cleaning stale lock"
        rm -f "$orchestrator_lock"
        exit 0
    fi
fi

# Check for active workers by scanning worker directories
if [ ! -d "$RALPH_DIR/workers" ]; then
    echo "No wiggum workers found"
    exit 0
fi

# Collect active workers from worker directories
declare -A worker_pids_map  # pid -> worker_id
for worker_dir in "$RALPH_DIR/workers"/worker-*; do
    [ -d "$worker_dir" ] || continue

    pid_file="$worker_dir/worker.pid"
    [ -f "$pid_file" ] || continue

    pid=$(cat "$pid_file" 2>/dev/null)
    worker_id=$(basename "$worker_dir")

    # Validate PID is a number
    if ! [[ "$pid" =~ ^[0-9]+$ ]]; then
        rm -f "$pid_file"
        continue
    fi

    if kill -0 "$pid" 2>/dev/null; then
        # Verify it's actually a worker process
        if ps -p "$pid" -o args= 2>/dev/null | grep -q "lib/worker.sh"; then
            worker_pids_map[$pid]="$worker_id"
        else
            # Stale PID file (PID reused)
            rm -f "$pid_file"
        fi
    else
        # Process no longer running
        rm -f "$pid_file"
    fi
done

# Check if any workers are running
if [ ${#worker_pids_map[@]} -eq 0 ]; then
    echo "No wiggum workers running"
    exit 0
fi

if [ -n "$SPECIFIC_WORKERS" ]; then
    # Stop specific workers only
    echo "Stopping specific workers..."

    # Convert comma-separated list to array
    IFS=',' read -ra PIDS_TO_STOP <<< "$SPECIFIC_WORKERS"

    declare -a pids_to_stop=()
    invalid_count=0
    for pid in "${PIDS_TO_STOP[@]}"; do
        # Trim whitespace
        pid=$(echo "$pid" | xargs)

        # Check if this PID is actually a managed worker
        if [ -z "${worker_pids_map[$pid]}" ]; then
            echo "Error: PID $pid is not a managed worker"
            ((invalid_count++))
            continue
        fi

        if kill -0 "$pid" 2>/dev/null; then
            echo "Stopping worker ${worker_pids_map[$pid]} (PID $pid)"
            kill -TERM "$pid"
            pids_to_stop+=("$pid")
        else
            echo "Worker PID $pid already stopped"
        fi
    done

    if [ $invalid_count -gt 0 ]; then
        echo ""
        echo "Warning: $invalid_count invalid PID(s) were skipped"
        echo "Use 'wiggum status' to see valid worker PIDs"
    fi

    # Wait for workers to stop (up to 10 seconds)
    if [ ${#pids_to_stop[@]} -gt 0 ]; then
        echo "Waiting for workers to terminate..."
        local timeout=10
        local elapsed=0
        local all_stopped=false

        while [ $elapsed -lt $timeout ]; do
            all_stopped=true
            for pid in "${pids_to_stop[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then
                    all_stopped=false
                    break
                fi
            done

            if [ "$all_stopped" = true ]; then
                break
            fi

            sleep 1
            ((elapsed++))
        done

        # Force kill any remaining workers
        if [ "$all_stopped" = false ]; then
            echo "Warning: Some workers did not stop gracefully, force killing..."
            for pid in "${pids_to_stop[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then
                    echo "Force killing ${worker_pids_map[$pid]} (PID $pid)"
                    kill -9 "$pid" 2>/dev/null || true
                fi
            done
            sleep 1
        fi

        # Count successfully stopped workers
        stopped_count=0
        for pid in "${pids_to_stop[@]}"; do
            if ! kill -0 "$pid" 2>/dev/null; then
                ((stopped_count++))
            fi
        done

        echo "Stopped $stopped_count workers"
    else
        echo "No workers were running"
    fi
else
    # Stop all workers
    echo "Stopping all workers..."

    # Send TERM signal to all workers
    declare -a pids_to_stop=()
    for pid in "${!worker_pids_map[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            echo "Stopping ${worker_pids_map[$pid]} (PID $pid)"
            kill -TERM "$pid"
            pids_to_stop+=("$pid")
        fi
    done

    # Wait for workers to stop (up to 10 seconds)
    if [ ${#pids_to_stop[@]} -gt 0 ]; then
        echo "Waiting for workers to terminate..."
        local timeout=10
        local elapsed=0
        local all_stopped=false

        while [ $elapsed -lt $timeout ]; do
            all_stopped=true
            for pid in "${pids_to_stop[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then
                    all_stopped=false
                    break
                fi
            done

            if [ "$all_stopped" = true ]; then
                break
            fi

            sleep 1
            ((elapsed++))
        done

        # Force kill any remaining workers
        if [ "$all_stopped" = false ]; then
            echo "Warning: Some workers did not stop gracefully, force killing..."
            for pid in "${pids_to_stop[@]}"; do
                if kill -0 "$pid" 2>/dev/null; then
                    echo "Force killing ${worker_pids_map[$pid]} (PID $pid)"
                    kill -9 "$pid" 2>/dev/null || true
                fi
            done
            sleep 1
        fi

        # Count successfully stopped workers
        stopped_count=0
        for pid in "${pids_to_stop[@]}"; do
            if ! kill -0 "$pid" 2>/dev/null; then
                ((stopped_count++))
            fi
        done

        echo "Stopped $stopped_count workers"
    else
        echo "No workers to stop"
    fi
fi
